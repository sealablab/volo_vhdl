---
title: "Volo VHDL Project Rules"
version: "1.0"
type: "workspace_rules"
applies_to: "all_files"
priority: "high"
---

# Volo VHDL Project - Agent Guidelines

## Overview
This document provides guidelines for AI agents working with the Volo VHDL project. The project follows strict VHDL-2008 coding standards designed for **Verilog portability**.

## Core Principles

### VHDL-2008 with Verilog Portability
- **Target**: VHDL-2008 that can be easily converted to Verilog
- **Avoid**: VHDL-only features that don't translate well to Verilog

### Allowed Features
- `std_logic` and `std_logic_vector` types
- `unsigned` and `signed` from `numeric_std` package
- Generics and generate statements
- Synchronous processes with `rising_edge(clk)`
- Synchronous reset mechanisms
- Explicit bit widths for all vectors

### Forbidden Features
- Records in port declarations (except in datadef packages)
- Subtype range constraints
- Enumeration types in RTL code
- Shared variables
- `wait` statements in RTL
- `after` delays
- Resolved custom types
- Physical types
- File I/O operations

## Port Naming Conventions

### Signal Prefixes
- **`ctrl_*`**: Control signals (enable, reset, etc.)
- **`cfg_*`**: Configuration parameters
- **`stat_*`**: Status and monitoring signals

### Port Structure
- Use flat ports (no records)
- Avoid complex type hierarchies
- Keep interfaces simple and Verilog-compatible

## Module Architecture

### Directory Structure
All VHDL modules must follow this standardized structure:
```
modules/
├── module_name/
│   ├── datadef/    # Data structure definitions (Tier 2 rules)
│   ├── common/     # RTL utility packages (Tier 1 rules)
│   ├── core/       # Main algorithmic/logic implementation (Tier 1 rules)
│   ├── top/        # Top-level integration (Tier 1 rules, optional)
│   └── tb/         # Testbenches (Tier 3 rules)
```

### Layer Responsibilities

#### Data Definition Layer (`modules/**/datadef/*.vhd`) - **NEW**
- **Purpose**: Define data structures, LUTs, and data validation utilities
- **Rule Tier**: Tier 2 (Relaxed rules for data definition)
- **Allowed Features**:
  - **Record types for data organization and type safety**
  - Array type definitions for LUTs and data structures
  - Complex constants and data initialization
  - Data validation functions (CRC, checksums)
  - Function overloading for data access utilities
  - Complex utility functions for data manipulation
- **Required**:
  - `cfg_*` prefixes for configuration data constants
  - Verilog conversion strategy documented in comments
  - Clear separation from RTL logic (no clocks, state machines)
  - No clock-dependent operations
  - **Records must be designed with Verilog conversion in mind**
- **Verilog Conversion Strategy**:
  - **Records → SystemVerilog structs or packed parameter arrays**
  - Array types → parameter arrays or .mem files
  - Complex functions → separate SystemVerilog modules
  - Function overloading → renamed functions with distinct names

#### Common Layer (`modules/**/common/*.vhd`)
- **Purpose**: Define shared types, constants, and utilities used across the module
- **Responsibilities**:
  - Configuration parameter validation functions
  - Utility functions shared across testbenches and modules
  - Common type definitions and constants

#### Core Layer (`modules/**/core/*.vhd`)
- **Purpose**: Pure logic implementation
- **Constraints**:
  - No register decode logic
  - No platform-specific code
  - Consume typed-by-name flat signals
  - Implement FSMs with `std_logic_vector` state encoding
  - Use constants for state labels (no enums)
  - **Create a default status register**
  - Ideally implement as a state machine

#### Top Layer (`modules/**/top/*.vhd`)
- **Purpose**: Integrate multiple modules and handle system-level concerns
- **Responsibilities**:
  - **External interface** - Connect to platform control system (generally a Moku CustomWrapper)
  - **Register exposure** - Expose appropriate control, configuration, and status registers
  - **Important**: DO NOT include MCC CustomWrapper entity body
  - Keep top-level modules clean and focused
  - **Note**: Not all modules will require a 'top' file

## FSM Implementation
- Use `std_logic_vector` for state encoding
- Define state constants (avoid enumeration types)
- Example:
  ```vhdl
  constant IDLE_STATE  : std_logic_vector(1 downto 0) := "00";
  constant ACTIVE_STATE: std_logic_vector(1 downto 0) := "01";
  ```

## Counters and Timers
- Prefer `unsigned` vectors with explicit widths
- Avoid generic ranges or complex constraints
- Example: `signal counter : unsigned(7 downto 0);`

## Code Style and Comments

### Block Structure
- Clearly mark the end of `if`/`elsif`/`case` blocks
- Use consistent indentation
- Add meaningful comments for complex logic

### Process Structure
- Use synchronous processes with `rising_edge(clk)`
- Implement proper reset handling
- Keep processes focused and readable

## Testbench Requirements (`modules/**/tb/*.vhd`)

### Allowed Features
- VHDL-2008 features are permitted
- `wait` statements are allowed
- Use deterministic stimuli

### Required Output
- **Success**: Print `'ALL TESTS PASSED'`
- **Failure**: Print `'TEST FAILED'`
- **Completion**: Always print `'SIMULATION DONE'`

## Template Guidelines (`templates/**`)
- Keep templates minimal
- Ensure Verilog portability
- Follow all global coding rules
- Provide clear examples of proper usage

## Best Practices

### Signal Declaration
```vhdl
signal data_bus : std_logic_vector(31 downto 0);
signal counter  : unsigned(15 downto 0);
signal state    : std_logic_vector(2 downto 0);
```

### Process Structure
```vhdl
process(clk, rst_n)
begin
    if rst_n = '0' then
        -- Reset logic
    elsif rising_edge(clk) then
        -- Synchronous logic
    end if;
end process;
```

### Generic Usage
```vhdl
generic (
    DATA_WIDTH : integer := 32;
    ADDR_WIDTH : integer := 8
);
```

## Verification Checklist
Before submitting code, ensure:
- [ ] No VHDL-only features used (except records in datadef packages)
- [ ] All ports use flat signal types (except datadef packages)
- [ ] FSMs use vector state encoding
- [ ] Proper signal prefixes (`ctrl_*`, `cfg_*`, `stat_*`)
- [ ] Explicit bit widths specified
- [ ] Synchronous processes with proper reset
- [ ] Clear block end markers
- [ ] Testbench prints required messages

## Questions for Clarification
When working on this project, consider asking:
1. What is the target frequency and timing requirements?
2. Are there specific power constraints or clock gating requirements?
3. What is the target FPGA/ASIC technology?
4. Are there specific verification requirements beyond the basic testbench rules?
5. What are the interface requirements with other modules?
6. Are there specific naming conventions for internal signals?
7. What are the reset requirements (synchronous vs asynchronous)?
8. Are there specific area or resource constraints?

---

## Tiered Rule System

The project uses a **three-tier rule system** to balance Verilog portability with practical VHDL development needs:

### **Tier 1: Strict RTL Rules** 
**Applies to**: `common/`, `core/`, `top/` directories

- **Strict Verilog portability** - All code must convert cleanly to Verilog
- **Forbidden**: Enumeration types, subtype constraints, complex functions
- **Required**: std_logic_vector state encoding, explicit bit widths
- **Purpose**: Synthesizable RTL that ports directly to Verilog

### **Tier 2: Relaxed Data Definition Rules**
**Applies to**: `datadef/` directories

- **Relaxed rules** for pure data structure definitions
- **Allowed**: Array types, complex constants, data validation functions
- **Forbidden**: Clock-dependent operations, state machines, RTL logic
- **Required**: Verilog conversion strategy documentation, `cfg_*` naming
- **Purpose**: Data structures and utilities that can be manually converted

### **Tier 3: Full VHDL-2008 Rules**
**Applies to**: `tb/` directories  

- **Full VHDL-2008 features** allowed
- **No portability constraints** - simulation-only code
- **Purpose**: Comprehensive testbenches and verification

### Rule Selection Guidelines

**Use Tier 1** for:
- All synthesizable RTL modules
- Interfaces between modules  
- Platform-specific implementations

**Use Tier 2** for:
- LUT definitions and data structures
- Configuration constants and parameters
- Data validation utilities
- Pure mathematical functions

**Use Tier 3** for:
- Testbenches and verification code
- Simulation-only utilities
- Debug and analysis functions

---

## Rules Application

```yaml
rules:
  # Tier 1: Strict RTL Rules (common/, core/, top/)
  tier1_rtl:
    directories: ["common", "core", "top"]
    coding_standards: "strict_verilog_portability"
    forbidden_features:
      - "enumeration_types"
      - "subtype_constraints" 
      - "records_in_ports"
      - "wait_statements_in_rtl"
      - "after_delays"
      - "complex_functions"
    required_features:
      - "std_logic_vector_state_encoding"
      - "explicit_bit_widths"
      - "synchronous_processes"
    naming_conventions:
      signals: ["ctrl_*", "cfg_*", "stat_*"]
      
  # Tier 2: Relaxed Data Definition Rules (datadef/)  
  tier2_datadef:
    directories: ["datadef"]
    coding_standards: "relaxed_for_data_structures"
    allowed_features:
      - "record_types_for_data_organization"
      - "array_type_definitions"
      - "complex_constants"
      - "data_validation_functions"
      - "function_overloading"
      - "complex_utility_functions"
    forbidden_features:
      - "clock_dependent_operations"
      - "state_machines"
      - "rtl_logic"
    required_features:
      - "cfg_prefix_for_constants"
      - "verilog_conversion_documentation"
      - "no_synthesizable_logic"
      - "records_designed_for_verilog_conversion"
    naming_conventions:
      constants: ["cfg_*"]
      
  # Tier 3: Full VHDL-2008 Rules (tb/)
  tier3_testbench:
    directories: ["tb"]
    coding_standards: "full_vhdl_2008"
    allowed_features: "all_vhdl_2008_features"
    forbidden_features: []
    required_outputs:
      success: "ALL TESTS PASSED"
      failure: "TEST FAILED"
      completion: "SIMULATION DONE"
      
  # Global Architecture Rules
  architecture:
    required_dirs: ["common", "core"] 
    optional_dirs: ["datadef", "top", "tb"]
    structure_validation: true
```